{"title":"Code Organization","markdown":{"headingText":"Code Organization","containsRefs":false,"markdown":"\nThis chapter discusses best practices for organizing your Python projects, especially those involving Bayesian methods.  Well-structured code is essential for readability, maintainability, and reproducibility – essential aspects of any serious data analysis project.\n\n### Organizing Files and Folders\n\nA clear file and folder structure is fundamental. Avoid dumping all your code into a single file. Instead, group related files logically.  For a Bayesian project, you might consider the following structure:\n\n* **`data/`**: Contains your raw data files (e.g., CSV, JSON).\n* **`src/`**:  Houses your Python source code.  Subfolders within `src/` could be organized by module (e.g., `src/models/`, `src/utils/`, `src/visualization/`).\n* **`notebooks/`**: Jupyter Notebooks for exploratory data analysis, model development, and reporting.\n* **`results/`**: Stores the output of your analyses (e.g., plots, tables, model parameters).\n* **`docs/`**: Contains documentation (e.g., README.md, user manuals).\n\n\n### Using Version Control (Git)\n\nVersion control is indispensable. Git allows you to track changes to your code, collaborate with others, and easily revert to previous versions if needed.  Use a platform like GitHub, GitLab, or Bitbucket to host your repository.  Remember to commit your changes frequently with descriptive messages.\n\nExample Git commands:\n\n```bash\ngit init             # Initialize a new Git repository\ngit add .            # Stage all changes\ngit commit -m \"Added Bayesian model implementation\"  # Commit changes with a message\ngit push origin main # Push changes to a remote repository\n```\n\n### Virtual Environments\n\nVirtual environments isolate project dependencies. This prevents conflicts between different projects that might rely on different versions of the same package.  Use `venv` (Python 3.3+) or `virtualenv` to create and manage environments.\n\n```bash\npython3 -m venv .venv  # Create a virtual environment\nsource .venv/bin/activate  # Activate the environment (Linux/macOS)\n.venv\\Scripts\\activate     # Activate the environment (Windows)\npip install numpy scipy matplotlib pymc3  # Install required packages\n```\n\n### Requirements Files (requirements.txt)\n\nA `requirements.txt` file lists all project dependencies and their versions. This ensures that others (and your future self) can easily reproduce your environment.  Generate it using:\n\n```bash\npip freeze > requirements.txt\n```\n\nTo recreate the environment:\n\n```bash\npip install -r requirements.txt\n```\n\n\n### Example Project Structure\n\nLet's consider a simple example:  estimating the probability of heads in a coin flip using a Bayesian approach.\n\n**Project Structure:**\n\n```\nbayesian_coin_flip/\n├── data/\n│   └── coin_flips.csv\n├── src/\n│   ├── models.py\n│   └── utils.py\n├── notebooks/\n│   └── coin_flip_analysis.ipynb\n├── results/\n│   └── posterior_distribution.png\n├── requirements.txt\n└── README.md\n```\n\n**`src/models.py`:**\n\n```{python}\n#| echo: true\nimport numpy as np\nimport pymc as pm\n\ndef bayesian_coin_flip(data):\n    with pm.Model() as model:\n        # Prior distribution for the probability of heads (uniform prior)\n        p = pm.Uniform(\"p\", lower=0, upper=1)\n\n        # Likelihood function (Binomial distribution)\n        y = pm.Binomial(\"y\", p=p, n=len(data), observed=np.sum(data))\n\n        # Posterior sampling using MCMC\n        trace = pm.sample(1000)\n\n    return trace\n\n```\n\n**`notebooks/coin_flip_analysis.ipynb`:** (Illustrative excerpt)\n\n```{python}\n#| echo: true\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom src.models import bayesian_coin_flip\n\n# Load data\ndata = pd.read_csv(\"data/coin_flips.csv\")['result'].astype(int)  #Assumes a column named 'result' with 1s and 0s\n\n# Perform Bayesian analysis\ntrace = bayesian_coin_flip(data)\n\n#Plot Posterior Distribution\nplt.figure(figsize=(8, 6))\nsns.histplot(trace.posterior['p'].values.flatten(), kde=True)\nplt.title('Posterior Distribution of p')\nplt.xlabel('Probability of Heads (p)')\nplt.ylabel('Density')\nplt.savefig('results/posterior_distribution.png')\nplt.show()\n\n\n# Calculate credible interval\nhdi_95 = pm.hdi(trace.posterior['p'])\nprint(f\"95% HDI: {hdi_95}\")\n\n```\n\n**LaTeX equation:**  The posterior distribution can be described using Bayes' Theorem:\n\n\n$P(p|y) = \\frac{P(y|p)P(p)}{P(y)}$\n\nWhere:\n\n* $P(p|y)$ is the posterior distribution of the probability of heads ($p$) given the observed data ($y$).\n* $P(y|p)$ is the likelihood function (Binomial distribution).\n* $P(p)$ is the prior distribution of $p$.\n* $P(y)$ is the marginal likelihood (evidence).\n\n\nThis example showcases a basic project structure.  More complex projects might require more elaborate organization, but the core principles remain the same:  clear separation of concerns, version control, and dependency management.\n\n\n## Writing Clean and Modular Code\n\nThis chapter focuses on writing well-structured, readable, and maintainable Python code for Bayesian analysis.  Clean code is essential for collaboration, debugging, and extending your work.\n\n### Functions for Bayesian Calculations\n\nBreak down your Bayesian calculations into reusable functions. This improves code readability and reduces redundancy. Each function should ideally perform a single, well-defined task.\n\n```{python}\n#| echo: true\nimport numpy as np\nimport scipy.stats as stats\n\ndef calculate_prior(alpha, beta):\n    \"\"\"Calculates a Beta prior distribution.\n\n    Args:\n        alpha: Shape parameter 1.\n        beta: Shape parameter 2.\n\n    Returns:\n        A scipy.stats.beta object representing the prior distribution.\n    \"\"\"\n    return stats.beta(alpha, beta)\n\n\ndef calculate_likelihood(data, p):\n    \"\"\"Calculates the likelihood given data and probability of success.\n\n    Args:\n        data: A NumPy array of 0s and 1s representing observations.\n        p: The probability of success.\n\n    Returns:\n        The likelihood (probability of the data given p).\n    \"\"\"\n    successes = np.sum(data)\n    n = len(data)\n    return stats.binom.pmf(successes, n, p)\n\n\ndef calculate_posterior(prior, likelihood, data):\n    \"\"\"Calculates the unnormalized posterior distribution.\n\n    Args:\n        prior: A scipy.stats.beta object.\n        likelihood: Likelihood function.\n        data: A NumPy array.\n\n    Returns:\n        A NumPy array representing the unnormalized posterior.\n    \"\"\"\n    p_range = np.linspace(0, 1, 1000)\n    prior_probs = prior.pdf(p_range)\n    likelihood_probs = likelihood(data, p_range)\n    unnormalized_posterior = prior_probs * likelihood_probs\n    return p_range, unnormalized_posterior\n\n```\n\n### Classes for Bayesian Models\n\nFor more complex models, using classes can greatly improve organization.  A class can encapsulate data, methods (functions), and attributes related to a specific Bayesian model.\n\n```{python}\n#| echo: true\nimport numpy as np\nimport pymc as pm\n\nclass BayesianLinearRegression:\n    def __init__(self, X, y):\n        self.X = X\n        self.y = y\n\n    def fit(self, prior_mu=0, prior_sigma=10):\n      with pm.Model() as self.model:\n          # Priors\n          intercept = pm.Normal(\"intercept\", mu=prior_mu, sigma=prior_sigma)\n          slope = pm.Normal(\"slope\", mu=prior_mu, sigma=prior_sigma)\n          sigma = pm.HalfNormal(\"sigma\", sigma=prior_sigma)\n          # Likelihood\n          mu = intercept + slope*self.X\n          y_obs = pm.Normal(\"y_obs\", mu=mu, sigma=sigma, observed=self.y)\n          #Posterior Sampling\n          self.trace = pm.sample(1000)\n\n    def predict(self, X_new):\n        # Get Posterior Predictive samples\n        posterior_predictive = pm.sample_posterior_predictive(self.trace, model=self.model, vars=[self.model[\"y_obs\"]])\n        return posterior_predictive[\"y_obs\"]\n```\n\n### Using Modules Effectively\n\nOrganize your code into modules (`.py` files) to improve structure and reusability.  Related functions and classes should reside in the same module.  This improves code maintainability and readability.\n\n\n### Code Readability and Style\n\nWrite code that is easy to understand. Use meaningful variable names, add comments to explain complex logic, and keep functions concise.\n\n* **Meaningful names:**  Instead of `x`, use `posterior_samples`.\n* **Comments:** Explain *why* the code does something, not just *what* it does.\n* **Concise functions:**  Aim for functions that perform a single, well-defined task.\n\n\n### Following PEP 8 Guidelines\n\nPEP 8 is the style guide for Python code. Adhering to PEP 8 ensures consistency and readability.  Tools like `pylint` and `flake8` can help enforce these guidelines.  Key aspects of PEP 8 include:\n\n* **Indentation:** Use 4 spaces for indentation.\n* **Line length:** Keep lines under 79 characters.\n* **Naming conventions:** Use lowercase with underscores for variables and functions (e.g., `my_variable`), and CamelCase for classes (e.g., `MyClass`).\n\nFollowing these principles results in clean, modular, and easily understandable Bayesian analysis code.  This is essential for both individual projects and collaborative efforts.\n\n\n## Testing Bayesian Models\n\nRigorous testing is essential for ensuring the correctness and reliability of your Bayesian models.  This section outlines strategies for testing different aspects of your Bayesian implementations.\n\n### Unit Testing with `unittest` or `pytest`\n\nUnit testing involves testing individual components of your code in isolation.  Python provides frameworks like `unittest` (built-in) and `pytest` (third-party) for writing unit tests.  Focus on testing individual functions and methods.\n\n**Example using `unittest`:**\n\n```{python}\n#| echo: true\nimport unittest\nimport numpy as np\nfrom src.my_bayesian_module import calculate_posterior  # Replace with your module\n\nclass TestBayesianCalculations(unittest.TestCase):\n    def test_posterior_calculation(self):\n        prior = np.array([0.1, 0.2, 0.7])  #Example Prior\n        likelihood = np.array([0.8, 0.6, 0.1]) #Example Likelihood\n        expected_posterior = np.array([0.08, 0.12, 0.07]) #Example Expected Posterior\n        posterior, _ = calculate_posterior(prior,likelihood)\n        np.testing.assert_allclose(posterior, expected_posterior, rtol=1e-05) # Check for near equality\n\nif __name__ == '__main__':\n    unittest.main()\n\n```\n\n**Example using `pytest`:** (requires installing `pytest`)\n\n```{python}\n#| echo: true\nimport numpy as np\nfrom src.my_bayesian_module import calculate_posterior\nimport pytest\n\ndef test_posterior_calculation():\n    prior = np.array([0.1, 0.2, 0.7])\n    likelihood = np.array([0.8, 0.6, 0.1])\n    expected_posterior = np.array([0.08, 0.12, 0.07])\n    posterior, _ = calculate_posterior(prior,likelihood)\n    np.testing.assert_allclose(posterior, expected_posterior, rtol=1e-05)\n\n```\n\n\n### Testing Prior and Posterior Distributions\n\nVerify that your prior and posterior distributions are correctly implemented and behave as expected. This could involve checking:\n\n* **Prior shape:**  Does the prior have the intended shape and parameters?  For example, is a Beta(2, 2) prior actually bell-shaped around 0.5?\n* **Posterior updates:** Does the posterior update correctly based on the observed data? Does it shift towards the data as expected?\n* **Numerical accuracy:** Are the numerical calculations (e.g., normalization, sampling) accurate?\n\n\n### Testing Model Accuracy and Convergence\n\nFor more complex models (e.g., hierarchical models), testing convergence of the Markov Chain Monte Carlo (MCMC) algorithm is crucial.  Check for:\n\n* **Trace plots:** Examine trace plots to visually inspect for convergence.  Do the chains mix well and reach a stable distribution?\n* **Gelman-Rubin diagnostic:** Use the Gelman-Rubin statistic ($\\hat{R}$) to assess convergence. Values close to 1 indicate convergence.  $\\hat{R} > 1.1$ often suggests non-convergence.\n* **Effective sample size:** Ensure the effective sample size (ESS) is sufficiently large for reliable estimates.\n\n### Integration Testing\n\nIntegration tests verify the interaction between different modules or components. For example, test the workflow from data loading, through model fitting, to result generation.\n\n\n### Continuous Integration (CI)\n\nContinuous Integration (CI) automates testing and build processes.  Services like GitHub Actions, GitLab CI, or Jenkins can be used to automatically run tests whenever code is pushed to the repository.  This helps catch errors early and ensures that your codebase remains stable and reliable.\n\nA simple CI workflow might involve:\n\n1.  Checkout code from the repository.\n2.  Create a virtual environment.\n3.  Install dependencies.\n4.  Run unit tests.\n5.  Run integration tests (optional).\n6.  Report the results.\n\n\nBy implementing these testing strategies, you'll build more robust and reliable Bayesian models in Python.  Detailed testing is an investment that pays off in terms of reduced debugging time and increased confidence in your results.\n\n\n## Documentation\n\nClear and detailed documentation is essential for any software project, especially those involving complex statistical methods like Bayesian analysis.  Good documentation helps others understand your code and reproduce your results.\n\n### Documenting Code with Docstrings\n\nDocstrings are string literals used to document Python code.  They are placed at the beginning of modules, classes, functions, and methods.  Use them to explain what a piece of code does, its parameters, return values, and any exceptions it might raise.\n\n```{python}\n#| echo: true\ndef calculate_posterior(prior, likelihood, data):\n    \"\"\"Calculates the unnormalized posterior distribution.\n\n    Args:\n        prior: A NumPy array representing the prior distribution.\n        likelihood: A NumPy array representing the likelihood function.\n        data: A NumPy array representing the observed data.\n\n    Returns:\n        A tuple containing:\n            - p_range: A NumPy array of probability values.\n            - unnormalized_posterior: A NumPy array representing the unnormalized posterior.\n\n    Raises:\n        ValueError: If input arrays have incompatible shapes.\n    \"\"\"\n    # ... code ...\n\n```\n\n### Generating API Documentation (Sphinx)\n\nSphinx is a popular tool for generating API documentation from docstrings.  It produces well-formatted HTML, PDF, or other output formats.  You'll need to install Sphinx and its extensions (e.g., `sphinx-rtd-theme`, `numpydoc`).\n\nA simple `conf.py` file for Sphinx might look like this (you'll need to adapt paths):\n\n```{python}\n#| echo: true\n# conf.py\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath('../src')) #Path to your source code\n\nproject = 'My Bayesian Project'\nhtml_theme = 'sphinx_rtd_theme'\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.napoleon', 'sphinx_rtd_theme']\n```\n\n\n### Writing Clear and Concise Comments\n\nUse comments to explain complex logic or non-obvious parts of your code. Keep comments concise and to the point.  Avoid redundant comments that simply restate the code.\n\n\n### Creating Readme Files\n\nA `README.md` file provides an overview of your project.  It should include:\n\n* A brief description of the project.\n* Installation instructions.\n* Usage examples.\n* Contributing guidelines.\n\nA well-written README is the first thing people see when they encounter your project.\n\n\n### Using Jupyter Notebooks for Examples\n\nJupyter Notebooks are excellent for creating interactive examples and tutorials. They combine code, text, and visualizations.  This makes them ideal for demonstrating how to use your Bayesian code.\n\n\n**Example Jupyter Notebook excerpt:**\n\n```{python}\n#| echo: true\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import beta\n\n# Prior distribution\nalpha_prior = 2\nbeta_prior = 2\nprior = beta(alpha_prior, beta_prior)\n\n# Generate samples from prior\nprior_samples = prior.rvs(1000)\n\n# Plot the prior\nplt.figure(figsize=(8, 6))\nplt.hist(prior_samples, bins=30, density=True, alpha=0.6, label='Prior')\nplt.title('Prior Distribution')\nplt.xlabel('Probability of Success')\nplt.ylabel('Density')\nplt.legend()\nplt.show()\n\n\n# LaTex equation for Beta distribution:\n# $f(x; \\alpha, \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{B(\\alpha, \\beta)}$  where $B(\\alpha, \\beta)$ is the Beta function.\n\n```\n\nThis shows a combination of code, a plot, and a LaTeX equation within a Jupyter Notebook to explain a Bayesian analysis concept.  By combining these techniques you significantly improve the understandability, accessibility, and maintainability of your Bayesian analysis projects.\n\n\n## Advanced Techniques\n\nThis section covers advanced techniques for improving the quality and efficiency of your Bayesian analysis code.\n\n### Refactoring Code\n\nRefactoring is the process of restructuring existing code without changing its external behavior.  It aims to improve code readability, maintainability, and efficiency.  Common refactoring techniques include:\n\n* **Extracting methods:** Break down large functions into smaller, more focused ones.\n* **Removing duplicated code:**  Identify and eliminate redundant code sections.\n* **Improving naming:** Use more descriptive and consistent variable and function names.\n* **Simplifying logic:**  Replace complex conditional statements with simpler alternatives.\n\nRefactoring is an iterative process that can significantly improve your codebase over time.\n\n### Code Optimization for Bayesian Computations\n\nBayesian computations can be computationally intensive. Optimization is essential for handling large datasets or complex models.  Techniques include:\n\n* **Vectorization:** Use NumPy's vectorized operations to avoid explicit loops. This uses NumPy's optimized C implementations for significant speedups.\n\n* **Just-in-time (JIT) compilation (Numba):** Numba compiles Python code to machine code at runtime, providing substantial performance gains, especially for numerical computations.\n\n```{python}\n#| echo: true\nimport numpy as np\nfrom numba import jit\n\n@jit(nopython=True)  # Decorate with @jit for JIT compilation\ndef slow_calculation(x):\n    result = 0\n    for i in range(len(x)):\n        result += x[i]**2\n    return result\n\n# Example using Numba for speedup\nx = np.random.rand(1000000)\n%timeit slow_calculation(x) #Measure without JIT\n@jit(nopython=True)\ndef fast_calculation(x):\n    return np.sum(x**2)\n%timeit fast_calculation(x) #Measure with JIT\n```\n\n\n* **Algorithmic optimization:** Choose efficient algorithms for sampling (e.g., Hamiltonian Monte Carlo, NUTS) and model fitting.  Consider the tradeoffs between accuracy and computational cost.\n\n\n### Profiling Code Performance\n\nProfiling helps identify performance bottlenecks in your code.  Tools like `cProfile` (built-in) or `line_profiler` (third-party) measure execution times of different code sections.\n\n\n```{python}\n#| echo: true\nimport cProfile\nimport my_bayesian_module\n\ncProfile.run('my_bayesian_module.run_model()')\n#This will output detailed profiling information.\n\n```\n\n\n### Debugging Bayesian Models\n\nDebugging Bayesian models can be challenging due to the inherent stochasticity and complexity. Strategies include:\n\n* **Print statements:** Insert `print` statements strategically to monitor variable values and intermediate results.\n\n* **Debuggers:** Use Python debuggers (e.g., `pdb`) to step through your code, inspect variables, and identify errors.\n\n* **Visualization:** Create plots of prior, posterior, and trace plots to help visually identify problems (e.g., non-convergence, unexpected behavior).\n\n* **Simplify the model:** Break down complex models into smaller, simpler parts for easier debugging.\n\n* **Check for numerical issues:**  Watch out for issues like underflow or overflow which can lead to unexpected results in probabilistic calculations.\n\n\n\nBy applying these advanced techniques, you can significantly improve the quality, efficiency, and reliability of your Bayesian analysis code. Remember that clean, well-documented, and well-tested code is essential for successful Bayesian modeling, especially in complex scenarios.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"output-file":"code-organization.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","jupyter":{"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"}},"bibliography":["../../references.bib"],"theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"lualatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","highlight-style":"printing","toc":true,"toc-depth":2,"include-in-header":{"text":"\\usepackage{geometry}\n\\usepackage{wrapfig}\n\\usepackage{fvextra}\n\\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\n\\geometry{\n    paperwidth=6in,\n    paperheight=9in,\n    textwidth=4.5in, % Adjust this to your preferred text width\n    textheight=6.5in,  % Adjust this to your preferred text height\n    inner=0.75in,    % Adjust margins as needed\n    outer=0.75in,\n    top=0.75in,\n    bottom=1in\n}\n\\usepackage{makeidx}\n\\usepackage{tabularx}\n\\usepackage{float}\n\\usepackage{graphicx}\n\\usepackage{array}\n\\graphicspath{{diagrams/}}\n\\makeindex\n"},"include-after-body":{"text":"\\printindex\n"},"output-file":"code-organization.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"jupyter":{"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"}},"bibliography":["../../references.bib"],"documentclass":"scrreprt","lof":false,"lot":false,"float":true,"classoption":"paper=6in:9in,pagesize=pdftex,footinclude=on,11pt","fig-cap-location":"top","urlcolor":"blue","linkcolor":"black","biblio-style":"apalike","code-block-bg":"#f0f0f0","code-block-border-left":"#000000","mermaid":{"theme":"neutral"},"fontfamily":"libertinus","monofont":"Consolas","monofontoptions":["Scale=0.7"],"template-partials":["../../before-body.tex"],"indent":true},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}